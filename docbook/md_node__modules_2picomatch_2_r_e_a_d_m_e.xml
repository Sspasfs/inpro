<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e" xml:lang="fr">
<title>README</title>
<indexterm><primary>README</primary></indexterm>

<para><formalpara><title>Picomatch</title></formalpara>
</para>

<para></para>

<para><link xlink:href="https://npmjs.org/package/picomatch"> </link> <link xlink:href="https://github.com/micromatch/picomatch/actions?workflow=Tests"> </link> <link xlink:href="https://coveralls.io/github/micromatch/picomatch"> </link> <link xlink:href="https://npmjs.org/package/picomatch"> </link> </para>

<para><?linebreak?> <?linebreak?></para>

<para></para>

<para><emphasis role="bold">Blazing fast and accurate glob matcher written in JavaScript.</emphasis> <emphasis>No dependencies and full support for standard and extended Bash glob features, including braces, extglobs, POSIX brackets, and regular expressions.</emphasis> </para>

<para><?linebreak?> <?linebreak?></para>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md641">
<title><title>Why picomatch?</title></title>

<para><itemizedlist>
<listitem>
<para><emphasis role="bold">Lightweight</emphasis> - No dependencies</para>
</listitem><listitem>
<para><emphasis role="bold">Minimal</emphasis> - Tiny API surface. Main export is a function that takes a glob pattern and returns a matcher function.</para>
</listitem><listitem>
<para><emphasis role="bold">Fast</emphasis> - Loads in about 2ms (that&apos;s several times faster than a <link xlink:href="http://www.endmemo.com/sconvert/framespersecondframespermillisecond.php">single frame of a HD movie</link> at 60fps)</para>
</listitem><listitem>
<para><emphasis role="bold">Performant</emphasis> - Use the returned matcher function to speed up repeat matching (like when watching files)</para>
</listitem><listitem>
<para><emphasis role="bold">Accurate matching</emphasis> - Using wildcards (<computeroutput>*</computeroutput> and <computeroutput>?</computeroutput>), globstars (<computeroutput>**</computeroutput>) for nested directories, advanced globbing with extglobs, braces, and POSIX brackets, and support for escaping special characters with <computeroutput>\</computeroutput> or quotes.</para>
</listitem><listitem>
<para><emphasis role="bold">Well tested</emphasis> - Thousands of unit tests</para>
</listitem></itemizedlist>
</para>

<para>See the library comparison to other libraries.</para>

<para><?linebreak?> <?linebreak?></para>
</section>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md642">
<title><title>Table of Contents</title></title>

<para>
<para><emphasis role="bold">Click to expand </emphasis></para><para>
<para></para>

<para><itemizedlist>
<listitem>
<para>Install</para>
</listitem><listitem>
<para>Usage</para>
</listitem><listitem>
<para>API<itemizedlist>
<listitem>
<para>picomatch</para>
</listitem><listitem>
<para>.test</para>
</listitem><listitem>
<para>.matchBase</para>
</listitem><listitem>
<para>.isMatch</para>
</listitem><listitem>
<para>.parse</para>
</listitem><listitem>
<para>.scan</para>
</listitem><listitem>
<para>.compileRe</para>
</listitem><listitem>
<para>.makeRe</para>
</listitem><listitem>
<para>.toRegex</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>Options<itemizedlist>
<listitem>
<para>Picomatch options</para>
</listitem><listitem>
<para>Scan Options</para>
</listitem><listitem>
<para>Options Examples</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>Globbing features<itemizedlist>
<listitem>
<para>Basic globbing</para>
</listitem><listitem>
<para>Advanced globbing</para>
</listitem><listitem>
<para>Braces</para>
</listitem><listitem>
<para>Matching special characters as literals</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>Library Comparisons</para>
</listitem><listitem>
<para>Benchmarks</para>
</listitem><listitem>
<para>Philosophies</para>
</listitem><listitem>
<para>About<itemizedlist>
<listitem>
<para>Author</para>
</listitem><listitem>
<para>License</para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>

<para>_(TOC generated by <link xlink:href="https://github.com/verbose/verb">verb</link> using <link xlink:href="https://github.com/jonschlinkert/markdown-toc">markdown-toc</link>)_</para>

<para></para>
</para>
</para>

<para><?linebreak?> <?linebreak?></para>
</section>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md643">
<title><title>Install</title></title>

<para>Install with <link xlink:href="https://www.npmjs.com/">npm</link>:</para>

<para><literallayout><computeroutput>npm&#32;install&#32;--save&#32;picomatch
</computeroutput></literallayout></para>

<para><?linebreak?></para>
</section>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md644">
<title><title>Usage</title></title>

<para>The main export is a function that takes a glob pattern and an options object and returns a function for matching strings.</para>

<para><literallayout><computeroutput>const&#32;pm&#32;=&#32;require(&apos;picomatch&apos;);
const&#32;isMatch&#32;=&#32;pm(&apos;*.js&apos;);

console.log(isMatch(&apos;abcd&apos;));&#32;//=&gt;&#32;false
console.log(isMatch(&apos;a.js&apos;));&#32;//=&gt;&#32;true
console.log(isMatch(&apos;a.md&apos;));&#32;//=&gt;&#32;false
console.log(isMatch(&apos;a/b.js&apos;));&#32;//=&gt;&#32;false
</computeroutput></literallayout></para>

<para><?linebreak?></para>
</section>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md645">
<title><title>API</title></title>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md646">
<title><title><link xlink:href="lib/picomatch.js#L32">picomatch</link></title></title>

<para>Creates a matcher function from one or more glob patterns. The returned function takes a string to match as its first argument, and returns true if the string is a match. The returned matcher function also takes a boolean as the second argument that, when true, returns an object with additional information.</para>

<para><emphasis role="bold">Params</emphasis></para>

<para><itemizedlist>
<listitem>
<para><computeroutput>globs</computeroutput> **{String|Array}**: One or more glob patterns.</para>
</listitem><listitem>
<para><computeroutput>options</computeroutput> **{Object=}**</para>
</listitem><listitem>
<para><computeroutput>returns</computeroutput> **{Function=}**: Returns a matcher function.</para>
</listitem></itemizedlist>
</para>

<para><emphasis role="bold">Example</emphasis></para>

<para><literallayout><computeroutput>const&#32;picomatch&#32;=&#32;require(&apos;picomatch&apos;);
//&#32;picomatch(glob[,&#32;options]);

const&#32;isMatch&#32;=&#32;picomatch(&apos;*.!(*a)&apos;);
console.log(isMatch(&apos;a.a&apos;));&#32;//=&gt;&#32;false
console.log(isMatch(&apos;a.b&apos;));&#32;//=&gt;&#32;true
</computeroutput></literallayout></para>
</section>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md647">
<title><title><link xlink:href="lib/picomatch.js#L117">.test</link></title></title>

<para>Test <computeroutput>input</computeroutput> with the given <computeroutput>regex</computeroutput>. This is used by the main <computeroutput>picomatch()</computeroutput> function to test the input string.</para>

<para><emphasis role="bold">Params</emphasis></para>

<para><itemizedlist>
<listitem>
<para><computeroutput>input</computeroutput> **{String}**: String to test.</para>
</listitem><listitem>
<para><computeroutput>regex</computeroutput> **{RegExp}**</para>
</listitem><listitem>
<para><computeroutput>returns</computeroutput> **{Object}**: Returns an object with matching info.</para>
</listitem></itemizedlist>
</para>

<para><emphasis role="bold">Example</emphasis></para>

<para><literallayout><computeroutput>const&#32;picomatch&#32;=&#32;require(&apos;picomatch&apos;);
//&#32;picomatch.test(input,&#32;regex[,&#32;options]);

console.log(picomatch.test(&apos;foo/bar&apos;,&#32;/^(?:([^/]*?)\/([^/]*?))$/));
//&#32;{&#32;isMatch:&#32;true,&#32;match:&#32;[&#32;&apos;foo/&apos;,&#32;&apos;foo&apos;,&#32;&apos;bar&apos;&#32;],&#32;output:&#32;&apos;foo/bar&apos;&#32;}
</computeroutput></literallayout></para>
</section>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md648">
<title><title><link xlink:href="lib/picomatch.js#L161">.matchBase</link></title></title>

<para>Match the basename of a filepath.</para>

<para><emphasis role="bold">Params</emphasis></para>

<para><itemizedlist>
<listitem>
<para><computeroutput>input</computeroutput> **{String}**: String to test.</para>
</listitem><listitem>
<para><computeroutput>glob</computeroutput> **{RegExp|String}**: Glob pattern or regex created by .makeRe.</para>
</listitem><listitem>
<para><computeroutput>returns</computeroutput> **{Boolean}**</para>
</listitem></itemizedlist>
</para>

<para><emphasis role="bold">Example</emphasis></para>

<para><literallayout><computeroutput>const&#32;picomatch&#32;=&#32;require(&apos;picomatch&apos;);
//&#32;picomatch.matchBase(input,&#32;glob[,&#32;options]);
console.log(picomatch.matchBase(&apos;foo/bar.js&apos;,&#32;&apos;*.js&apos;);&#32;//&#32;true
</computeroutput></literallayout></para>
</section>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md649">
<title><title><link xlink:href="lib/picomatch.js#L183">.isMatch</link></title></title>

<para>Returns true if <emphasis role="bold">any</emphasis> of the given glob <computeroutput>patterns</computeroutput> match the specified <computeroutput>string</computeroutput>.</para>

<para><emphasis role="bold">Params</emphasis></para>

<para><itemizedlist>
<listitem>
<para>**{String|Array}**: str The string to test.</para>
</listitem><listitem>
<para>**{String|Array}**: patterns One or more glob patterns to use for matching.</para>
</listitem><listitem>
<para>**{Object}**: See available options.</para>
</listitem><listitem>
<para><computeroutput>returns</computeroutput> **{Boolean}**: Returns true if any patterns match <computeroutput>str</computeroutput></para>
</listitem></itemizedlist>
</para>

<para><emphasis role="bold">Example</emphasis></para>

<para><literallayout><computeroutput>const&#32;picomatch&#32;=&#32;require(&apos;picomatch&apos;);
//&#32;picomatch.isMatch(string,&#32;patterns[,&#32;options]);

console.log(picomatch.isMatch(&apos;a.a&apos;,&#32;[&apos;b.*&apos;,&#32;&apos;*.a&apos;]));&#32;//=&gt;&#32;true
console.log(picomatch.isMatch(&apos;a.a&apos;,&#32;&apos;b.*&apos;));&#32;//=&gt;&#32;false
</computeroutput></literallayout></para>
</section>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md650">
<title><title><link xlink:href="lib/picomatch.js#L199">.parse</link></title></title>

<para>Parse a glob pattern to create the source string for a regular expression.</para>

<para><emphasis role="bold">Params</emphasis></para>

<para><itemizedlist>
<listitem>
<para><computeroutput>pattern</computeroutput> **{String}**</para>
</listitem><listitem>
<para><computeroutput>options</computeroutput> **{Object}**</para>
</listitem><listitem>
<para><computeroutput>returns</computeroutput> **{Object}**: Returns an object with useful properties and output to be used as a regex source string.</para>
</listitem></itemizedlist>
</para>

<para><emphasis role="bold">Example</emphasis></para>

<para><literallayout><computeroutput>const&#32;picomatch&#32;=&#32;require(&apos;picomatch&apos;);
const&#32;result&#32;=&#32;picomatch.parse(pattern[,&#32;options]);
</computeroutput></literallayout></para>
</section>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md651">
<title><title><link xlink:href="lib/picomatch.js#L231">.scan</link></title></title>

<para>Scan a glob pattern to separate the pattern into segments.</para>

<para><emphasis role="bold">Params</emphasis></para>

<para><itemizedlist>
<listitem>
<para><computeroutput>input</computeroutput> **{String}**: Glob pattern to scan.</para>
</listitem><listitem>
<para><computeroutput>options</computeroutput> **{Object}**</para>
</listitem><listitem>
<para><computeroutput>returns</computeroutput> **{Object}**: Returns an object with</para>
</listitem></itemizedlist>
</para>

<para><emphasis role="bold">Example</emphasis></para>

<para><literallayout><computeroutput>const&#32;picomatch&#32;=&#32;require(&apos;picomatch&apos;);
//&#32;picomatch.scan(input[,&#32;options]);

const&#32;result&#32;=&#32;picomatch.scan(&apos;!./foo/*.js&apos;);
console.log(result);
{&#32;prefix:&#32;&apos;!./&apos;,
&#32;&#32;input:&#32;&apos;!./foo/*.js&apos;,
&#32;&#32;start:&#32;3,
&#32;&#32;base:&#32;&apos;foo&apos;,
&#32;&#32;glob:&#32;&apos;*.js&apos;,
&#32;&#32;isBrace:&#32;false,
&#32;&#32;isBracket:&#32;false,
&#32;&#32;isGlob:&#32;true,
&#32;&#32;isExtglob:&#32;false,
&#32;&#32;isGlobstar:&#32;false,
&#32;&#32;negated:&#32;true&#32;}
</computeroutput></literallayout></para>
</section>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md652">
<title><title><link xlink:href="lib/picomatch.js#L245">.compileRe</link></title></title>

<para>Compile a regular expression from the <computeroutput>state</computeroutput> object returned by the parse() method.</para>

<para><emphasis role="bold">Params</emphasis></para>

<para><itemizedlist>
<listitem>
<para><computeroutput>state</computeroutput> **{Object}**</para>
</listitem><listitem>
<para><computeroutput>options</computeroutput> **{Object}**</para>
</listitem><listitem>
<para><computeroutput>returnOutput</computeroutput> **{Boolean}**: Intended for implementors, this argument allows you to return the raw output from the parser.</para>
</listitem><listitem>
<para><computeroutput>returnState</computeroutput> **{Boolean}**: Adds the state to a <computeroutput>state</computeroutput> property on the returned regex. Useful for implementors and debugging.</para>
</listitem><listitem>
<para><computeroutput>returns</computeroutput> **{RegExp}**</para>
</listitem></itemizedlist>
</para>
</section>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md653">
<title><title><link xlink:href="lib/picomatch.js#L286">.makeRe</link></title></title>

<para>Create a regular expression from a parsed glob pattern.</para>

<para><emphasis role="bold">Params</emphasis></para>

<para><itemizedlist>
<listitem>
<para><computeroutput>state</computeroutput> **{String}**: The object returned from the <computeroutput>.parse</computeroutput> method.</para>
</listitem><listitem>
<para><computeroutput>options</computeroutput> **{Object}**</para>
</listitem><listitem>
<para><computeroutput>returnOutput</computeroutput> **{Boolean}**: Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.</para>
</listitem><listitem>
<para><computeroutput>returnState</computeroutput> **{Boolean}**: Implementors may use this argument to return the state from the parsed glob with the returned regular expression.</para>
</listitem><listitem>
<para><computeroutput>returns</computeroutput> **{RegExp}**: Returns a regex created from the given pattern.</para>
</listitem></itemizedlist>
</para>

<para><emphasis role="bold">Example</emphasis></para>

<para><literallayout><computeroutput>const&#32;picomatch&#32;=&#32;require(&apos;picomatch&apos;);
const&#32;state&#32;=&#32;picomatch.parse(&apos;*.js&apos;);
//&#32;picomatch.compileRe(state[,&#32;options]);

console.log(picomatch.compileRe(state));
//=&gt;&#32;/^(?:(?!\.)(?=.)[^/]*?\.js)$/
</computeroutput></literallayout></para>
</section>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md654">
<title><title><link xlink:href="lib/picomatch.js#L321">.toRegex</link></title></title>

<para>Create a regular expression from the given regex source string.</para>

<para><emphasis role="bold">Params</emphasis></para>

<para><itemizedlist>
<listitem>
<para><computeroutput>source</computeroutput> **{String}**: Regular expression source string.</para>
</listitem><listitem>
<para><computeroutput>options</computeroutput> **{Object}**</para>
</listitem><listitem>
<para><computeroutput>returns</computeroutput> **{RegExp}**</para>
</listitem></itemizedlist>
</para>

<para><emphasis role="bold">Example</emphasis></para>

<para><literallayout><computeroutput>const&#32;picomatch&#32;=&#32;require(&apos;picomatch&apos;);
//&#32;picomatch.toRegex(source[,&#32;options]);

const&#32;{&#32;output&#32;}&#32;=&#32;picomatch.parse(&apos;*.js&apos;);
console.log(picomatch.toRegex(output));
//=&gt;&#32;/^(?:(?!\.)(?=.)[^/]*?\.js)$/
</computeroutput></literallayout></para>

<para><?linebreak?></para>
</section>
</section>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md655">
<title><title>Options</title></title>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md656">
<title><title>Picomatch options</title></title>

<para>The following options may be used with the main <computeroutput>picomatch()</computeroutput> function or any of the methods on the picomatch API.</para>

<para><informaltable frame="all">
    <tgroup cols="4" align="left" colsep="1" rowsep="1">
      <colspec colname='c1'/>
      <colspec colname='c2'/>
      <colspec colname='c3'/>
      <colspec colname='c4'/>
<thead>
      <row  class='markdownTableHead'>
<entry>
<para><emphasis role="bold">Option</emphasis>   </para>
</entry><entry>
<para><emphasis role="bold">Type</emphasis>   </para>
</entry><entry>
<para><emphasis role="bold">Default value</emphasis>   </para>
</entry><entry>
<para><emphasis role="bold">Description</emphasis>    </para>
</entry></row>
</thead><tbody>
      <row  class='markdownTableRowOdd'>
<entry>
<para><computeroutput>basename</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>false</computeroutput>   </para>
</entry><entry>
<para>If set, then patterns without slashes will be matched against the basename of the path if it contains slashes. For example, <computeroutput>a?b</computeroutput> would match the path <computeroutput>/xyz/123/acb</computeroutput>, but not <computeroutput>/xyz/acb/123</computeroutput>.    </para>
</entry></row>
      <row  class='markdownTableRowEven'>
<entry>
<para><computeroutput>bash</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>false</computeroutput>   </para>
</entry><entry>
<para>Follow bash matching rules more strictly - disallows backslashes as escape characters, and treats single stars as globstars (<computeroutput>**</computeroutput>).    </para>
</entry></row>
      <row  class='markdownTableRowOdd'>
<entry>
<para><computeroutput>capture</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>undefined</computeroutput>   </para>
</entry><entry>
<para>Return regex matches in supporting methods.    </para>
</entry></row>
      <row  class='markdownTableRowEven'>
<entry>
<para><computeroutput>contains</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>undefined</computeroutput>   </para>
</entry><entry>
<para>Allows glob to match any part of the given string(s).    </para>
</entry></row>
      <row  class='markdownTableRowOdd'>
<entry>
<para><computeroutput>cwd</computeroutput>   </para>
</entry><entry>
<para><computeroutput>string</computeroutput>   </para>
</entry><entry>
<para><computeroutput>process.cwd()</computeroutput>   </para>
</entry><entry>
<para>Current working directory. Used by <computeroutput>picomatch.split()</computeroutput>    </para>
</entry></row>
      <row  class='markdownTableRowEven'>
<entry>
<para><computeroutput>debug</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>undefined</computeroutput>   </para>
</entry><entry>
<para>Debug regular expressions when an error is thrown.    </para>
</entry></row>
      <row  class='markdownTableRowOdd'>
<entry>
<para><computeroutput>dot</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>false</computeroutput>   </para>
</entry><entry>
<para>Enable dotfile matching. By default, dotfiles are ignored unless a <computeroutput>.</computeroutput> is explicitly defined in the pattern, or <computeroutput>options.dot</computeroutput> is true    </para>
</entry></row>
      <row  class='markdownTableRowEven'>
<entry>
<para><computeroutput>expandRange</computeroutput>   </para>
</entry><entry>
<para><computeroutput>function</computeroutput>   </para>
</entry><entry>
<para><computeroutput>undefined</computeroutput>   </para>
</entry><entry>
<para>Custom function for expanding ranges in brace patterns, such as <computeroutput>{a..z}</computeroutput>. The function receives the range values as two arguments, and it must return a string to be used in the generated regex. It&apos;s recommended that returned strings be wrapped in parentheses.    </para>
</entry></row>
      <row  class='markdownTableRowOdd'>
<entry>
<para><computeroutput>failglob</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>false</computeroutput>   </para>
</entry><entry>
<para>Throws an error if no matches are found. Based on the bash option of the same name.    </para>
</entry></row>
      <row  class='markdownTableRowEven'>
<entry>
<para><computeroutput>fastpaths</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>true</computeroutput>   </para>
</entry><entry>
<para>To speed up processing, full parsing is skipped for a handful common glob patterns. Disable this behavior by setting this option to <computeroutput>false</computeroutput>.    </para>
</entry></row>
      <row  class='markdownTableRowOdd'>
<entry>
<para><computeroutput>flags</computeroutput>   </para>
</entry><entry>
<para><computeroutput>string</computeroutput>   </para>
</entry><entry>
<para><computeroutput>undefined</computeroutput>   </para>
</entry><entry>
<para>Regex flags to use in the generated regex. If defined, the <computeroutput>nocase</computeroutput> option will be overridden.    </para>
</entry></row>
      <row  class='markdownTableRowEven'>
<entry>
<para>format   </para>
</entry><entry>
<para><computeroutput>function</computeroutput>   </para>
</entry><entry>
<para><computeroutput>undefined</computeroutput>   </para>
</entry><entry>
<para>Custom function for formatting the returned string. This is useful for removing leading slashes, converting Windows paths to Posix paths, etc.    </para>
</entry></row>
      <row  class='markdownTableRowOdd'>
<entry>
<para><computeroutput>ignore</computeroutput>   </para>
</entry><entry>
<para><computeroutput>array\|string</computeroutput>   </para>
</entry><entry>
<para><computeroutput>undefined</computeroutput>   </para>
</entry><entry>
<para>One or more glob patterns for excluding strings that should not be matched from the result.    </para>
</entry></row>
      <row  class='markdownTableRowEven'>
<entry>
<para><computeroutput>keepQuotes</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>false</computeroutput>   </para>
</entry><entry>
<para>Retain quotes in the generated regex, since quotes may also be used as an alternative to backslashes.    </para>
</entry></row>
      <row  class='markdownTableRowOdd'>
<entry>
<para><computeroutput>literalBrackets</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>undefined</computeroutput>   </para>
</entry><entry>
<para>When <computeroutput>true</computeroutput>, brackets in the glob pattern will be escaped so that only literal brackets will be matched.    </para>
</entry></row>
      <row  class='markdownTableRowEven'>
<entry>
<para><computeroutput>matchBase</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>false</computeroutput>   </para>
</entry><entry>
<para>Alias for <computeroutput>basename</computeroutput>    </para>
</entry></row>
      <row  class='markdownTableRowOdd'>
<entry>
<para><computeroutput>maxLength</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>65536</computeroutput>   </para>
</entry><entry>
<para>Limit the max length of the input string. An error is thrown if the input string is longer than this value.    </para>
</entry></row>
      <row  class='markdownTableRowEven'>
<entry>
<para><computeroutput>nobrace</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>false</computeroutput>   </para>
</entry><entry>
<para>Disable brace matching, so that <computeroutput>{a,b}</computeroutput> and <computeroutput>{1..3}</computeroutput> would be treated as literal characters.    </para>
</entry></row>
      <row  class='markdownTableRowOdd'>
<entry>
<para><computeroutput>nobracket</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>undefined</computeroutput>   </para>
</entry><entry>
<para>Disable matching with regex brackets.    </para>
</entry></row>
      <row  class='markdownTableRowEven'>
<entry>
<para><computeroutput>nocase</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>false</computeroutput>   </para>
</entry><entry>
<para>Make matching case-insensitive. Equivalent to the regex <computeroutput>i</computeroutput> flag. Note that this option is overridden by the <computeroutput>flags</computeroutput> option.    </para>
</entry></row>
      <row  class='markdownTableRowOdd'>
<entry>
<para><computeroutput>nodupes</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>true</computeroutput>   </para>
</entry><entry>
<para>Deprecated, use <computeroutput>nounique</computeroutput> instead. This option will be removed in a future major release. By default duplicates are removed. Disable uniquification by setting this option to false.    </para>
</entry></row>
      <row  class='markdownTableRowEven'>
<entry>
<para><computeroutput>noext</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>false</computeroutput>   </para>
</entry><entry>
<para>Alias for <computeroutput>noextglob</computeroutput>    </para>
</entry></row>
      <row  class='markdownTableRowOdd'>
<entry>
<para><computeroutput>noextglob</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>false</computeroutput>   </para>
</entry><entry>
<para>Disable support for matching with extglobs (like <computeroutput>+(a\|b)</computeroutput>)    </para>
</entry></row>
      <row  class='markdownTableRowEven'>
<entry>
<para><computeroutput>noglobstar</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>false</computeroutput>   </para>
</entry><entry>
<para>Disable support for matching nested directories with globstars (<computeroutput>**</computeroutput>)    </para>
</entry></row>
      <row  class='markdownTableRowOdd'>
<entry>
<para><computeroutput>nonegate</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>false</computeroutput>   </para>
</entry><entry>
<para>Disable support for negating with leading <computeroutput>!</computeroutput>    </para>
</entry></row>
      <row  class='markdownTableRowEven'>
<entry>
<para><computeroutput>noquantifiers</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>false</computeroutput>   </para>
</entry><entry>
<para>Disable support for regex quantifiers (like <computeroutput>a{1,2}</computeroutput>) and treat them as brace patterns to be expanded.    </para>
</entry></row>
      <row  class='markdownTableRowOdd'>
<entry>
<para>onIgnore   </para>
</entry><entry>
<para><computeroutput>function</computeroutput>   </para>
</entry><entry>
<para><computeroutput>undefined</computeroutput>   </para>
</entry><entry>
<para>Function to be called on ignored items.    </para>
</entry></row>
      <row  class='markdownTableRowEven'>
<entry>
<para>onMatch   </para>
</entry><entry>
<para><computeroutput>function</computeroutput>   </para>
</entry><entry>
<para><computeroutput>undefined</computeroutput>   </para>
</entry><entry>
<para>Function to be called on matched items.    </para>
</entry></row>
      <row  class='markdownTableRowOdd'>
<entry>
<para>onResult   </para>
</entry><entry>
<para><computeroutput>function</computeroutput>   </para>
</entry><entry>
<para><computeroutput>undefined</computeroutput>   </para>
</entry><entry>
<para>Function to be called on all items, regardless of whether or not they are matched or ignored.    </para>
</entry></row>
      <row  class='markdownTableRowEven'>
<entry>
<para><computeroutput>posix</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>false</computeroutput>   </para>
</entry><entry>
<para>Support POSIX character classes (&quot;posix brackets&quot;).    </para>
</entry></row>
      <row  class='markdownTableRowOdd'>
<entry>
<para><computeroutput>posixSlashes</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>undefined</computeroutput>   </para>
</entry><entry>
<para>Convert all slashes in file paths to forward slashes. This does not convert slashes in the glob pattern itself    </para>
</entry></row>
      <row  class='markdownTableRowEven'>
<entry>
<para><computeroutput>prepend</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>undefined</computeroutput>   </para>
</entry><entry>
<para>String to prepend to the generated regex used for matching.    </para>
</entry></row>
      <row  class='markdownTableRowOdd'>
<entry>
<para><computeroutput>regex</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>false</computeroutput>   </para>
</entry><entry>
<para>Use regular expression rules for <computeroutput>+</computeroutput> (instead of matching literal <computeroutput>+</computeroutput>), and for stars that follow closing parentheses or brackets (as in <computeroutput>)*</computeroutput> and <computeroutput>]*</computeroutput>).    </para>
</entry></row>
      <row  class='markdownTableRowEven'>
<entry>
<para><computeroutput>strictBrackets</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>undefined</computeroutput>   </para>
</entry><entry>
<para>Throw an error if brackets, braces, or parens are imbalanced.    </para>
</entry></row>
      <row  class='markdownTableRowOdd'>
<entry>
<para><computeroutput>strictSlashes</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>undefined</computeroutput>   </para>
</entry><entry>
<para>When true, picomatch won&apos;t match trailing slashes with single stars.    </para>
</entry></row>
      <row  class='markdownTableRowEven'>
<entry>
<para><computeroutput>unescape</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>undefined</computeroutput>   </para>
</entry><entry>
<para>Remove backslashes preceding escaped characters in the glob pattern. By default, backslashes are retained.    </para>
</entry></row>
      <row  class='markdownTableRowOdd'>
<entry>
<para><computeroutput>unixify</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>undefined</computeroutput>   </para>
</entry><entry>
<para>Alias for <computeroutput>posixSlashes</computeroutput>, for backwards compatibility.   </para>
</entry></row>
    </tbody>
    </tgroup>
</informaltable>
</para>

<para>picomatch has automatic detection for regex positive and negative lookbehinds. If the pattern contains a negative lookbehind, you must be using Node.js &gt;= 8.10 or else picomatch will throw an error.</para>
</section>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md657">
<title><title>Scan Options</title></title>

<para>In addition to the main picomatch options, the following options may also be used with the .scan method.</para>

<para><informaltable frame="all">
    <tgroup cols="4" align="left" colsep="1" rowsep="1">
      <colspec colname='c1'/>
      <colspec colname='c2'/>
      <colspec colname='c3'/>
      <colspec colname='c4'/>
<thead>
      <row  class='markdownTableHead'>
<entry>
<para><emphasis role="bold">Option</emphasis>   </para>
</entry><entry>
<para><emphasis role="bold">Type</emphasis>   </para>
</entry><entry>
<para><emphasis role="bold">Default value</emphasis>   </para>
</entry><entry>
<para><emphasis role="bold">Description</emphasis>    </para>
</entry></row>
</thead><tbody>
      <row  class='markdownTableRowOdd'>
<entry>
<para><computeroutput>tokens</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>false</computeroutput>   </para>
</entry><entry>
<para>When <computeroutput>true</computeroutput>, the returned object will include an array of tokens (objects), representing each path &quot;segment&quot; in the scanned glob pattern    </para>
</entry></row>
      <row  class='markdownTableRowEven'>
<entry>
<para><computeroutput>parts</computeroutput>   </para>
</entry><entry>
<para><computeroutput>boolean</computeroutput>   </para>
</entry><entry>
<para><computeroutput>false</computeroutput>   </para>
</entry><entry>
<para>When <computeroutput>true</computeroutput>, the returned object will include an array of strings representing each path &quot;segment&quot; in the scanned glob pattern. This is automatically enabled when <computeroutput>options.tokens</computeroutput> is true   </para>
</entry></row>
    </tbody>
    </tgroup>
</informaltable>
</para>

<para><emphasis role="bold">Example</emphasis></para>

<para><literallayout><computeroutput>const&#32;picomatch&#32;=&#32;require(&apos;picomatch&apos;);
const&#32;result&#32;=&#32;picomatch.scan(&apos;!./foo/*.js&apos;,&#32;{&#32;tokens:&#32;true&#32;});
console.log(result);
//&#32;{
//&#32;&#32;&#32;prefix:&#32;&apos;!./&apos;,
//&#32;&#32;&#32;input:&#32;&apos;!./foo/*.js&apos;,
//&#32;&#32;&#32;start:&#32;3,
//&#32;&#32;&#32;base:&#32;&apos;foo&apos;,
//&#32;&#32;&#32;glob:&#32;&apos;*.js&apos;,
//&#32;&#32;&#32;isBrace:&#32;false,
//&#32;&#32;&#32;isBracket:&#32;false,
//&#32;&#32;&#32;isGlob:&#32;true,
//&#32;&#32;&#32;isExtglob:&#32;false,
//&#32;&#32;&#32;isGlobstar:&#32;false,
//&#32;&#32;&#32;negated:&#32;true,
//&#32;&#32;&#32;maxDepth:&#32;2,
//&#32;&#32;&#32;tokens:&#32;[
//&#32;&#32;&#32;&#32;&#32;{&#32;value:&#32;&apos;!./&apos;,&#32;depth:&#32;0,&#32;isGlob:&#32;false,&#32;negated:&#32;true,&#32;isPrefix:&#32;true&#32;},
//&#32;&#32;&#32;&#32;&#32;{&#32;value:&#32;&apos;foo&apos;,&#32;depth:&#32;1,&#32;isGlob:&#32;false&#32;},
//&#32;&#32;&#32;&#32;&#32;{&#32;value:&#32;&apos;*.js&apos;,&#32;depth:&#32;1,&#32;isGlob:&#32;true&#32;}
//&#32;&#32;&#32;],
//&#32;&#32;&#32;slashes:&#32;[&#32;2,&#32;6&#32;],
//&#32;&#32;&#32;parts:&#32;[&#32;&apos;foo&apos;,&#32;&apos;*.js&apos;&#32;]
//&#32;}
</computeroutput></literallayout></para>

<para><?linebreak?></para>
</section>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md658">
<title><title>Options Examples</title></title>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md659">
<title><title>options.expandRange</title></title>

<para><emphasis role="bold">Type</emphasis>: <computeroutput>function</computeroutput></para>

<para><emphasis role="bold">Default</emphasis>: <computeroutput>undefined</computeroutput></para>

<para>Custom function for expanding ranges in brace patterns. The <link xlink:href="https://github.com/jonschlinkert/fill-range">fill-range</link> library is ideal for this purpose, or you can use custom code to do whatever you need.</para>

<para><emphasis role="bold">Example</emphasis></para>

<para>The following example shows how to create a glob that matches a folder</para>

<para><literallayout><computeroutput>const&#32;fill&#32;=&#32;require(&apos;fill-range&apos;);
const&#32;regex&#32;=&#32;pm.makeRe(&apos;foo/{01..25}/bar&apos;,&#32;{
&#32;&#32;expandRange(a,&#32;b)&#32;{
&#32;&#32;&#32;&#32;return&#32;`(${fill(a,&#32;b,&#32;{&#32;toRegex:&#32;true&#32;})})`;
&#32;&#32;}
});

console.log(regex);
//=&gt;&#32;/^(?:foo\/((?:0[1-9]|1[0-9]|2[0-5]))\/bar)$/

console.log(regex.test(&apos;foo/00/bar&apos;))&#32;&#32;//&#32;false
console.log(regex.test(&apos;foo/01/bar&apos;))&#32;&#32;//&#32;true
console.log(regex.test(&apos;foo/10/bar&apos;))&#32;//&#32;true
console.log(regex.test(&apos;foo/22/bar&apos;))&#32;//&#32;true
console.log(regex.test(&apos;foo/25/bar&apos;))&#32;//&#32;true
console.log(regex.test(&apos;foo/26/bar&apos;))&#32;//&#32;false
</computeroutput></literallayout></para>
</section>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md660">
<title><title>options.format</title></title>

<para><emphasis role="bold">Type</emphasis>: <computeroutput>function</computeroutput></para>

<para><emphasis role="bold">Default</emphasis>: <computeroutput>undefined</computeroutput></para>

<para>Custom function for formatting strings before they&apos;re matched.</para>

<para><emphasis role="bold">Example</emphasis></para>

<para><literallayout><computeroutput>//&#32;strip&#32;leading&#32;&apos;./&apos;&#32;from&#32;strings
const&#32;format&#32;=&#32;str&#32;=&gt;&#32;str.replace(/^\.\//,&#32;&apos;&apos;);
const&#32;isMatch&#32;=&#32;picomatch(&apos;foo/*.js&apos;,&#32;{&#32;format&#32;});
console.log(isMatch(&apos;./foo/bar.js&apos;));&#32;//=&gt;&#32;true
</computeroutput></literallayout></para>
</section>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md661">
<title><title>options.onMatch</title></title>

<para><literallayout><computeroutput>const&#32;onMatch&#32;=&#32;({&#32;glob,&#32;regex,&#32;input,&#32;output&#32;})&#32;=&gt;&#32;{
&#32;&#32;console.log({&#32;glob,&#32;regex,&#32;input,&#32;output&#32;});
};

const&#32;isMatch&#32;=&#32;picomatch(&apos;*&apos;,&#32;{&#32;onMatch&#32;});
isMatch(&apos;foo&apos;);
isMatch(&apos;bar&apos;);
isMatch(&apos;baz&apos;);
</computeroutput></literallayout></para>
</section>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md662">
<title><title>options.onIgnore</title></title>

<para><literallayout><computeroutput>const&#32;onIgnore&#32;=&#32;({&#32;glob,&#32;regex,&#32;input,&#32;output&#32;})&#32;=&gt;&#32;{
&#32;&#32;console.log({&#32;glob,&#32;regex,&#32;input,&#32;output&#32;});
};

const&#32;isMatch&#32;=&#32;picomatch(&apos;*&apos;,&#32;{&#32;onIgnore,&#32;ignore:&#32;&apos;f*&apos;&#32;});
isMatch(&apos;foo&apos;);
isMatch(&apos;bar&apos;);
isMatch(&apos;baz&apos;);
</computeroutput></literallayout></para>
</section>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md663">
<title><title>options.onResult</title></title>

<para><literallayout><computeroutput>const&#32;onResult&#32;=&#32;({&#32;glob,&#32;regex,&#32;input,&#32;output&#32;})&#32;=&gt;&#32;{
&#32;&#32;console.log({&#32;glob,&#32;regex,&#32;input,&#32;output&#32;});
};

const&#32;isMatch&#32;=&#32;picomatch(&apos;*&apos;,&#32;{&#32;onResult,&#32;ignore:&#32;&apos;f*&apos;&#32;});
isMatch(&apos;foo&apos;);
isMatch(&apos;bar&apos;);
isMatch(&apos;baz&apos;);
</computeroutput></literallayout></para>

<para><?linebreak?> <?linebreak?></para>
</section>
</section>
</section>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md664">
<title><title>Globbing features</title></title>

<para><itemizedlist>
<listitem>
<para>Basic globbing (Wildcard matching)</para>
</listitem><listitem>
<para>Advanced globbing (extglobs, posix brackets, brace matching)</para>
</listitem></itemizedlist>
</para>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md665">
<title><title>Basic globbing</title></title>

<para><informaltable frame="all">
    <tgroup cols="2" align="left" colsep="1" rowsep="1">
      <colspec colname='c1'/>
      <colspec colname='c2'/>
<thead>
      <row  class='markdownTableHead'>
<entry>
<para><emphasis role="bold">Character</emphasis>   </para>
</entry><entry>
<para><emphasis role="bold">Description</emphasis>    </para>
</entry></row>
</thead><tbody>
      <row  class='markdownTableRowOdd'>
<entry>
<para><computeroutput>*</computeroutput>   </para>
</entry><entry>
<para>Matches any character zero or more times, excluding path separators. Does <emphasis>not match</emphasis> path separators or hidden files or directories (&quot;dotfiles&quot;), unless explicitly enabled by setting the <computeroutput>dot</computeroutput> option to <computeroutput>true</computeroutput>.    </para>
</entry></row>
      <row  class='markdownTableRowEven'>
<entry>
<para><computeroutput>**</computeroutput>   </para>
</entry><entry>
<para>Matches any character zero or more times, including path separators. Note that <computeroutput>**</computeroutput> will only match path separators (<computeroutput>/</computeroutput>, and <computeroutput>\\</computeroutput> on Windows) when they are the only characters in a path segment. Thus, <computeroutput>foo**/bar</computeroutput> is equivalent to <computeroutput>foo*/bar</computeroutput>, and <computeroutput>foo/a**b/bar</computeroutput> is equivalent to <computeroutput>foo/a*b/bar</computeroutput>, and <emphasis>more than two</emphasis> consecutive stars in a glob path segment are regarded as <emphasis>a single star</emphasis>. Thus, <computeroutput>foo/***/bar</computeroutput> is equivalent to <computeroutput>foo/*/bar</computeroutput>.    </para>
</entry></row>
      <row  class='markdownTableRowOdd'>
<entry>
<para><computeroutput>?</computeroutput>   </para>
</entry><entry>
<para>Matches any character excluding path separators one time. Does <emphasis>not match</emphasis> path separators or leading dots.    </para>
</entry></row>
      <row  class='markdownTableRowEven'>
<entry>
<para><computeroutput>[abc]</computeroutput>   </para>
</entry><entry>
<para>Matches any characters inside the brackets. For example, <computeroutput>[abc]</computeroutput> would match the characters <computeroutput>a</computeroutput>, <computeroutput>b</computeroutput> or <computeroutput>c</computeroutput>, and nothing else.   </para>
</entry></row>
    </tbody>
    </tgroup>
</informaltable>
</para>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md666">
<title><title>Matching behavior vs. Bash</title></title>

<para>Picomatch&apos;s matching features and expected results in unit tests are based on Bash&apos;s unit tests and the Bash 4.3 specification, with the following exceptions:</para>

<para><itemizedlist>
<listitem>
<para>Bash will match <computeroutput>foo/bar/baz</computeroutput> with <computeroutput>*</computeroutput>. Picomatch only matches nested directories with <computeroutput>**</computeroutput>.</para>
</listitem><listitem>
<para>Bash greedily matches with negated extglobs. For example, Bash 4.3 says that <computeroutput>!(foo)*</computeroutput> should match <computeroutput>foo</computeroutput> and <computeroutput>foobar</computeroutput>, since the trailing <computeroutput>*</computeroutput> bracktracks to match the preceding pattern. This is very memory-inefficient, and IMHO, also incorrect. Picomatch would return <computeroutput>false</computeroutput> for both <computeroutput>foo</computeroutput> and <computeroutput>foobar</computeroutput>.</para>
</listitem></itemizedlist>
</para>

<para><?linebreak?></para>
</section>
</section>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md667">
<title><title>Advanced globbing</title></title>

<para><itemizedlist>
<listitem>
<para>extglobs</para>
</listitem><listitem>
<para>POSIX brackets</para>
</listitem><listitem>
<para>Braces</para>
</listitem></itemizedlist>
</para>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md668">
<title><title>Extglobs</title></title>

<para><informaltable frame="all">
    <tgroup cols="2" align="left" colsep="1" rowsep="1">
      <colspec colname='c1'/>
      <colspec colname='c2'/>
<thead>
      <row  class='markdownTableHead'>
<entry>
<para><emphasis role="bold">Pattern</emphasis>   </para>
</entry><entry>
<para><emphasis role="bold">Description</emphasis>    </para>
</entry></row>
</thead><tbody>
      <row  class='markdownTableRowOdd'>
<entry>
<para><computeroutput>@(pattern)</computeroutput>   </para>
</entry><entry>
<para>Match <emphasis>only one</emphasis> consecutive occurrence of <computeroutput>pattern</computeroutput>    </para>
</entry></row>
      <row  class='markdownTableRowEven'>
<entry>
<para><computeroutput>*(pattern)</computeroutput>   </para>
</entry><entry>
<para>Match <emphasis>zero or more</emphasis> consecutive occurrences of <computeroutput>pattern</computeroutput>    </para>
</entry></row>
      <row  class='markdownTableRowOdd'>
<entry>
<para><computeroutput>+(pattern)</computeroutput>   </para>
</entry><entry>
<para>Match <emphasis>one or more</emphasis> consecutive occurrences of <computeroutput>pattern</computeroutput>    </para>
</entry></row>
      <row  class='markdownTableRowEven'>
<entry>
<para><computeroutput>?(pattern)</computeroutput>   </para>
</entry><entry>
<para>Match <emphasis>zero or <emphasis role="bold">one</emphasis></emphasis> consecutive occurrences of <computeroutput>pattern</computeroutput>    </para>
</entry></row>
      <row  class='markdownTableRowOdd'>
<entry>
<para><computeroutput>!(pattern)</computeroutput>   </para>
</entry><entry>
<para>Match <emphasis>anything but</emphasis> <computeroutput>pattern</computeroutput>   </para>
</entry></row>
    </tbody>
    </tgroup>
</informaltable>
</para>

<para><emphasis role="bold">Examples</emphasis></para>

<para><literallayout><computeroutput>const&#32;pm&#32;=&#32;require(&apos;picomatch&apos;);

//&#32;*(pattern)&#32;matches&#32;ZERO&#32;or&#32;more&#32;of&#32;&quot;pattern&quot;
console.log(pm.isMatch(&apos;a&apos;,&#32;&apos;a*(z)&apos;));&#32;//&#32;true
console.log(pm.isMatch(&apos;az&apos;,&#32;&apos;a*(z)&apos;));&#32;//&#32;true
console.log(pm.isMatch(&apos;azzz&apos;,&#32;&apos;a*(z)&apos;));&#32;//&#32;true

//&#32;+(pattern)&#32;matches&#32;ONE&#32;or&#32;more&#32;of&#32;&quot;pattern&quot;
console.log(pm.isMatch(&apos;a&apos;,&#32;&apos;a*(z)&apos;));&#32;//&#32;true
console.log(pm.isMatch(&apos;az&apos;,&#32;&apos;a*(z)&apos;));&#32;//&#32;true
console.log(pm.isMatch(&apos;azzz&apos;,&#32;&apos;a*(z)&apos;));&#32;//&#32;true

//&#32;supports&#32;multiple&#32;extglobs
console.log(pm.isMatch(&apos;foo.bar&apos;,&#32;&apos;!(foo).!(bar)&apos;));&#32;//&#32;false

//&#32;supports&#32;nested&#32;extglobs
console.log(pm.isMatch(&apos;foo.bar&apos;,&#32;&apos;!(!(foo)).!(!(bar))&apos;));&#32;//&#32;true
</computeroutput></literallayout></para>
</section>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md669">
<title><title>POSIX brackets</title></title>

<para>POSIX classes are disabled by default. Enable this feature by setting the <computeroutput>posix</computeroutput> option to true.</para>

<para><emphasis role="bold">Enable POSIX bracket support</emphasis></para>

<para><literallayout><computeroutput>console.log(pm.makeRe(&apos;[[:word:]]+&apos;,&#32;{&#32;posix:&#32;true&#32;}));
//=&gt;&#32;/^(?:(?=.)[A-Za-z0-9_]+\/?)$/
</computeroutput></literallayout></para>

<para><emphasis role="bold">Supported POSIX classes</emphasis></para>

<para>The following named POSIX bracket expressions are supported:</para>

<para><itemizedlist>
<listitem>
<para><computeroutput>[:alnum:]</computeroutput> - Alphanumeric characters, equ <computeroutput>[a-zA-Z0-9]</computeroutput></para>
</listitem><listitem>
<para><computeroutput>[:alpha:]</computeroutput> - Alphabetical characters, equivalent to <computeroutput>[a-zA-Z]</computeroutput>.</para>
</listitem><listitem>
<para><computeroutput>[:ascii:]</computeroutput> - ASCII characters, equivalent to <computeroutput>[\\x00-\\x7F]</computeroutput>.</para>
</listitem><listitem>
<para><computeroutput>[:blank:]</computeroutput> - Space and tab characters, equivalent to <computeroutput>[ \\t]</computeroutput>.</para>
</listitem><listitem>
<para><computeroutput>[:cntrl:]</computeroutput> - Control characters, equivalent to <computeroutput>[\\x00-\\x1F\\x7F]</computeroutput>.</para>
</listitem><listitem>
<para><computeroutput>[:digit:]</computeroutput> - Numerical digits, equivalent to <computeroutput>[0-9]</computeroutput>.</para>
</listitem><listitem>
<para><computeroutput>[:graph:]</computeroutput> - Graph characters, equivalent to <computeroutput>[\\x21-\\x7E]</computeroutput>.</para>
</listitem><listitem>
<para><computeroutput>[:lower:]</computeroutput> - Lowercase letters, equivalent to <computeroutput>[a-z]</computeroutput>.</para>
</listitem><listitem>
<para><computeroutput>[:print:]</computeroutput> - Print characters, equivalent to <computeroutput>[\\x20-\\x7E ]</computeroutput>.</para>
</listitem><listitem>
<para><computeroutput>[:punct:]</computeroutput> - Punctuation and symbols, equivalent to &#8216;[\-!&quot;#$%&amp;\&#8217;()\\*+,./:;&lt;=&gt;?@[\\]^_&lt;tt&gt;{|}~]&lt;/tt&gt;.
* &lt;tt&gt;[:space:]&lt;/tt&gt; - Extended space characters, equivalent to &lt;tt&gt;[ \\\\t\\\\r\\\\n\\\\v\\\\f]&lt;/tt&gt;.
* &lt;tt&gt;[:upper:]&lt;/tt&gt; - Uppercase letters, equivalent to &lt;tt&gt;[A-Z]&lt;/tt&gt;.
* &lt;tt&gt;[:word:]&lt;/tt&gt; -  Word characters (letters, numbers and underscores), equivalent to &lt;tt&gt;[A-Za-z0-9_]&lt;/tt&gt;.
* &lt;tt&gt;[:xdigit:]&lt;/tt&gt; - Hexadecimal digits, equivalent to &lt;tt&gt;[A-Fa-f0-9]&lt;/tt&gt;.

See the &lt;a href=&quot;<link xlink:href="https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html">https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html</link>&quot; &gt;Bash Reference Manual&lt;/a&gt; for more information.

@subsubsection autotoc_md670 Braces

Picomatch does not do brace expansion. For &lt;a href=&quot;<link xlink:href="https://www.gnu.org/software/bash/manual/html_node/Brace-Expansion.html">https://www.gnu.org/software/bash/manual/html_node/Brace-Expansion.html</link>&quot; &gt;brace expansion&lt;/a&gt; and advanced matching with braces, use &lt;a href=&quot;<link xlink:href="https://github.com/micromatch/micromatch">https://github.com/micromatch/micromatch</link>&quot; &gt;micromatch&lt;/a&gt; instead. Picomatch has very basic support for braces.

@subsubsection autotoc_md671 Matching special characters as literals

If you wish to match the following special characters in a filepath, and you want to use these characters in your glob pattern, they must be escaped with backslashes or quotes:

&lt;strong&gt;Special Characters&lt;/strong&gt;

Some characters that are used for matching in regular expressions are also regarded as valid file path characters on some platforms.

To match any of the following characters as literals: `$^*+?()[]

Examples:

@icode{js} 
console.log(pm.makeRe(&apos;foo/bar \\(1\\)&apos;));
console.log(pm.makeRe(&apos;foo/bar \\(1\\)&apos;));
@endicode 

&lt;br&gt;
&lt;br&gt;

@subsection autotoc_md672 Library Comparisons

The following table shows which features are supported by &lt;a href=&quot;<link xlink:href="https://github.com/isaacs/minimatch">https://github.com/isaacs/minimatch</link>&quot; &gt;minimatch&lt;/a&gt;, &lt;a href=&quot;<link xlink:href="https://github.com/micromatch/micromatch">https://github.com/micromatch/micromatch</link>&quot; &gt;micromatch&lt;/a&gt;, &lt;a href=&quot;<link xlink:href="https://github.com/micromatch/picomatch">https://github.com/micromatch/picomatch</link>&quot; &gt;picomatch&lt;/a&gt;, &lt;a href=&quot;<link xlink:href="https://github.com/micromatch/nanomatch">https://github.com/micromatch/nanomatch</link>&quot; &gt;nanomatch&lt;/a&gt;, &lt;a href=&quot;<link xlink:href="https://github.com/micromatch/extglob">https://github.com/micromatch/extglob</link>&quot; &gt;extglob&lt;/a&gt;, &lt;a href=&quot;<link xlink:href="https://github.com/micromatch/braces">https://github.com/micromatch/braces</link>&quot; &gt;braces&lt;/a&gt;, and &lt;a href=&quot;<link xlink:href="https://github.com/micromatch/expand-brackets">https://github.com/micromatch/expand-brackets</link>&quot; &gt;expand-brackets&lt;/a&gt;.

&lt;table class=&quot;markdownTable&quot;&gt;
  &lt;tr class=&quot;markdownTableHead&quot;&gt;    &lt;th class=&quot;markdownTableHeadNone&quot;&gt; <emphasis role="bold">Feature</emphasis>   </para>
</listitem></itemizedlist>
</para>

<para><computeroutput>minimatch</computeroutput>   </para>

<para><computeroutput>micromatch</computeroutput>   </para>

<para><computeroutput>picomatch</computeroutput>   </para>

<para><computeroutput>nanomatch</computeroutput>   </para>

<para><computeroutput>extglob</computeroutput>   </para>

<para><computeroutput>braces</computeroutput>   </para>

<para><computeroutput>expand-brackets</computeroutput>    </para>

<para>Wildcard matching (<computeroutput>*?+</computeroutput>)   </para>

<para>✔   </para>

<para>✔   </para>

<para>✔   </para>

<para>✔   </para>

<para>-   </para>

<para>-   </para>

<para>-    </para>

<para>Advancing globbing   </para>

<para>✔   </para>

<para>✔   </para>

<para>✔   </para>

<para>-   </para>

<para>-   </para>

<para>-   </para>

<para>-    </para>

<para>Brace <emphasis>matching</emphasis>   </para>

<para>✔   </para>

<para>✔   </para>

<para>✔   </para>

<para>-   </para>

<para>-   </para>

<para>✔   </para>

<para>-    </para>

<para>Brace <emphasis>expansion</emphasis>   </para>

<para>✔   </para>

<para>✔   </para>

<para>-   </para>

<para>-   </para>

<para>-   </para>

<para>✔   </para>

<para>-    </para>

<para>Extglobs   </para>

<para>partial   </para>

<para>✔   </para>

<para>✔   </para>

<para>-   </para>

<para>✔   </para>

<para>-   </para>

<para>-    </para>

<para>Posix brackets   </para>

<para>-   </para>

<para>✔   </para>

<para>✔   </para>

<para>-   </para>

<para>-   </para>

<para>-   </para>

<para>✔    </para>

<para>Regular expression syntax   </para>

<para>-   </para>

<para>✔   </para>

<para>✔   </para>

<para>✔   </para>

<para>✔   </para>

<para>-   </para>

<para>✔    </para>

<para>File system operations   </para>

<para>-   </para>

<para>-   </para>

<para>-   </para>

<para>-   </para>

<para>-   </para>

<para>-   </para>

<para>-   </para>

<para><?linebreak?> <?linebreak?></para>
</section>
</section>
</section>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md673">
<title><title>Benchmarks</title></title>

<para>Performance comparison of picomatch and minimatch.</para>

<para><literallayout><computeroutput>#&#32;.makeRe&#32;star
&#32;&#32;picomatch&#32;x&#32;1,993,050&#32;ops/sec&#32;±0.51%&#32;(91&#32;runs&#32;sampled)
&#32;&#32;minimatch&#32;x&#32;627,206&#32;ops/sec&#32;±1.96%&#32;(87&#32;runs&#32;sampled))

#&#32;.makeRe&#32;star;&#32;dot=true
&#32;&#32;picomatch&#32;x&#32;1,436,640&#32;ops/sec&#32;±0.62%&#32;(91&#32;runs&#32;sampled)
&#32;&#32;minimatch&#32;x&#32;525,876&#32;ops/sec&#32;±0.60%&#32;(88&#32;runs&#32;sampled)

#&#32;.makeRe&#32;globstar
&#32;&#32;picomatch&#32;x&#32;1,592,742&#32;ops/sec&#32;±0.42%&#32;(90&#32;runs&#32;sampled)
&#32;&#32;minimatch&#32;x&#32;962,043&#32;ops/sec&#32;±1.76%&#32;(91&#32;runs&#32;sampled)d)

#&#32;.makeRe&#32;globstars
&#32;&#32;picomatch&#32;x&#32;1,615,199&#32;ops/sec&#32;±0.35%&#32;(94&#32;runs&#32;sampled)
&#32;&#32;minimatch&#32;x&#32;477,179&#32;ops/sec&#32;±1.33%&#32;(91&#32;runs&#32;sampled)

#&#32;.makeRe&#32;with&#32;leading&#32;star
&#32;&#32;picomatch&#32;x&#32;1,220,856&#32;ops/sec&#32;±0.40%&#32;(92&#32;runs&#32;sampled)
&#32;&#32;minimatch&#32;x&#32;453,564&#32;ops/sec&#32;±1.43%&#32;(94&#32;runs&#32;sampled)

#&#32;.makeRe&#32;-&#32;basic&#32;braces
&#32;&#32;picomatch&#32;x&#32;392,067&#32;ops/sec&#32;±0.70%&#32;(90&#32;runs&#32;sampled)
&#32;&#32;minimatch&#32;x&#32;99,532&#32;ops/sec&#32;±2.03%&#32;(87&#32;runs&#32;sampled))
</computeroutput></literallayout></para>

<para><?linebreak?> <?linebreak?></para>
</section>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md674">
<title><title>Philosophies</title></title>

<para>The goal of this library is to be blazing fast, without compromising on accuracy.</para>

<para><emphasis role="bold">Accuracy</emphasis></para>

<para>The number one of goal of this library is accuracy. However, it&apos;s not unusual for different glob implementations to have different rules for matching behavior, even with simple wildcard matching. It gets increasingly more complicated when combinations of different features are combined, like when extglobs are combined with globstars, braces, slashes, and so on: <computeroutput>!(**/{a,b,*/c})</computeroutput>.</para>

<para>Thus, given that there is no canonical glob specification to use as a single source of truth when differences of opinion arise regarding behavior, sometimes we have to implement our best judgement and rely on feedback from users to make improvements.</para>

<para><emphasis role="bold">Performance</emphasis></para>

<para>Although this library performs well in benchmarks, and in most cases it&apos;s faster than other popular libraries we benchmarked against, we will always choose accuracy over performance. It&apos;s not helpful to anyone if our library is faster at returning the wrong answer.</para>

<para><?linebreak?> <?linebreak?></para>
</section>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md675">
<title><title>About</title></title>

<para>
<para><emphasis role="bold"><emphasis role="bold">Contributing</emphasis></emphasis></para><para>
<para></para>

<para>Pull requests and stars are always welcome. For bugs and feature requests, <link xlink:href="../../issues/new">please create an issue</link>.</para>

<para>Please read the contributing guide for advice on opening issues, pull requests, and coding standards.</para>

<para></para>
</para>
</para>

<para>
<para><emphasis role="bold"><emphasis role="bold">Running Tests</emphasis></emphasis></para><para>
<para></para>

<para>Running and reviewing unit tests is a great way to get familiarized with a library and its API. You can install dependencies and run tests with the following command:</para>

<para><literallayout><computeroutput>npm&#32;install&#32;&amp;&amp;&#32;npm&#32;test
</computeroutput></literallayout></para>

<para></para>
</para>
</para>

<para>
<para><emphasis role="bold"><emphasis role="bold">Building docs</emphasis></emphasis></para><para>
<para></para>

<para>_(This project&apos;s readme.md is generated by <link xlink:href="https://github.com/verbose/verb-generate-readme">verb</link>, please don&apos;t edit the readme directly. Any changes to the readme must be made in the .verb.md readme template.)_</para>

<para>To generate the readme, run the following command:</para>

<para><literallayout><computeroutput>npm&#32;install&#32;-g&#32;verbose/verb#dev&#32;verb-generate-readme&#32;&amp;&amp;&#32;verb
</computeroutput></literallayout></para>

<para></para>
</para>
</para>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md676">
<title><title>Author</title></title>

<para><emphasis role="bold">Jon Schlinkert</emphasis></para>

<para><itemizedlist>
<listitem>
<para><link xlink:href="https://github.com/jonschlinkert">GitHub Profile</link></para>
</listitem><listitem>
<para><link xlink:href="https://twitter.com/jonschlinkert">Twitter Profile</link></para>
</listitem><listitem>
<para><link xlink:href="https://linkedin.com/in/jonschlinkert">LinkedIn Profile</link></para>
</listitem></itemizedlist>
</para>
</section>
<section xml:id="_md_node__modules_2picomatch_2_r_e_a_d_m_e_1autotoc_md677">
<title><title>License</title></title>

<para>Copyright © 2017-present, <link xlink:href="https://github.com/jonschlinkert">Jon Schlinkert</link>. Released under the [MIT License](LICENSE). </para>
</section>
</section>
</section>
